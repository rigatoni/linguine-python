#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import cogcomp.base.BaseService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(cogcomp.base.BaseService.Iface):
  def describeAnnotations(self):
    """
    Returns a map of view_names to annotation server names. Useful for
    inspecting the annotations available via the curator.
    """
    pass

  def isCacheAvailable(self):
    """
    Is caching enabled on this server?
    """
    pass

  def provide(self, view_name, text, forceUpdate):
    """
    Provide annotation of view_name for a given text. forceUpdate forces the
    annotation to be reprocessed even if it is available in the cache.

    Parameters:
     - view_name
     - text
     - forceUpdate
    """
    pass

  def wsprovide(self, view_name, sentences, forceUpdate):
    """
    Provide annotation of view_name for a given list of strings.  Each string
    will be tokenized on whitespace and each string should represent one
    sentence. forceUpdate forces the annotation to be reprocessed even if it is
    available in the cache.

    Parameters:
     - view_name
     - sentences
     - forceUpdate
    """
    pass

  def getRecord(self, text):
    """
    Returns the Record for a given text.

    Parameters:
     - text
    """
    pass

  def wsgetRecord(self, sentences):
    """
    Returns the Record for a given list of strings. Each string will be
    tokenized on whitespace and each string should represent one sentence.

    Parameters:
     - sentences
    """
    pass

  def getRecordById(self, identifier):
    """
    Returns the Record associated with a given identifier.

    Parameters:
     - identifier
    """
    pass

  def storeRecord(self, record):
    """
    Store the given Record.  Usually disabled.

    Parameters:
     - record
    """
    pass

  def getMultiRecord(self, texts):
    """
    Returns a MultiRecord for a given list of texts.

    Parameters:
     - texts
    """
    pass

  def provideMulti(self, view_name, texts, forceUpdate):
    """
    Provides the view_name for multiple texts in a MultiRecord.

    Parameters:
     - view_name
     - texts
     - forceUpdate
    """
    pass

  def storeMultiRecord(self, record):
    """
    Store the given MultiRecord.  Usually disabled.

    Parameters:
     - record
    """
    pass


class Client(cogcomp.base.BaseService.Client, Iface):
  def __init__(self, iprot, oprot=None):
    cogcomp.base.BaseService.Client.__init__(self, iprot, oprot)

  def describeAnnotations(self):
    """
    Returns a map of view_names to annotation server names. Useful for
    inspecting the annotations available via the curator.
    """
    self.send_describeAnnotations()
    return self.recv_describeAnnotations()

  def send_describeAnnotations(self):
    self._oprot.writeMessageBegin('describeAnnotations', TMessageType.CALL, self._seqid)
    args = describeAnnotations_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeAnnotations(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = describeAnnotations_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeAnnotations failed: unknown result");

  def isCacheAvailable(self):
    """
    Is caching enabled on this server?
    """
    self.send_isCacheAvailable()
    return self.recv_isCacheAvailable()

  def send_isCacheAvailable(self):
    self._oprot.writeMessageBegin('isCacheAvailable', TMessageType.CALL, self._seqid)
    args = isCacheAvailable_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_isCacheAvailable(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = isCacheAvailable_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "isCacheAvailable failed: unknown result");

  def provide(self, view_name, text, forceUpdate):
    """
    Provide annotation of view_name for a given text. forceUpdate forces the
    annotation to be reprocessed even if it is available in the cache.

    Parameters:
     - view_name
     - text
     - forceUpdate
    """
    self.send_provide(view_name, text, forceUpdate)
    return self.recv_provide()

  def send_provide(self, view_name, text, forceUpdate):
    self._oprot.writeMessageBegin('provide', TMessageType.CALL, self._seqid)
    args = provide_args()
    args.view_name = view_name
    args.text = text
    args.forceUpdate = forceUpdate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_provide(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = provide_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.suex is not None:
      raise result.suex
    if result.afex is not None:
      raise result.afex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "provide failed: unknown result");

  def wsprovide(self, view_name, sentences, forceUpdate):
    """
    Provide annotation of view_name for a given list of strings.  Each string
    will be tokenized on whitespace and each string should represent one
    sentence. forceUpdate forces the annotation to be reprocessed even if it is
    available in the cache.

    Parameters:
     - view_name
     - sentences
     - forceUpdate
    """
    self.send_wsprovide(view_name, sentences, forceUpdate)
    return self.recv_wsprovide()

  def send_wsprovide(self, view_name, sentences, forceUpdate):
    self._oprot.writeMessageBegin('wsprovide', TMessageType.CALL, self._seqid)
    args = wsprovide_args()
    args.view_name = view_name
    args.sentences = sentences
    args.forceUpdate = forceUpdate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_wsprovide(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = wsprovide_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.suex is not None:
      raise result.suex
    if result.afex is not None:
      raise result.afex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "wsprovide failed: unknown result");

  def getRecord(self, text):
    """
    Returns the Record for a given text.

    Parameters:
     - text
    """
    self.send_getRecord(text)
    return self.recv_getRecord()

  def send_getRecord(self, text):
    self._oprot.writeMessageBegin('getRecord', TMessageType.CALL, self._seqid)
    args = getRecord_args()
    args.text = text
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecord(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecord_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecord failed: unknown result");

  def wsgetRecord(self, sentences):
    """
    Returns the Record for a given list of strings. Each string will be
    tokenized on whitespace and each string should represent one sentence.

    Parameters:
     - sentences
    """
    self.send_wsgetRecord(sentences)
    return self.recv_wsgetRecord()

  def send_wsgetRecord(self, sentences):
    self._oprot.writeMessageBegin('wsgetRecord', TMessageType.CALL, self._seqid)
    args = wsgetRecord_args()
    args.sentences = sentences
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_wsgetRecord(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = wsgetRecord_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "wsgetRecord failed: unknown result");

  def getRecordById(self, identifier):
    """
    Returns the Record associated with a given identifier.

    Parameters:
     - identifier
    """
    self.send_getRecordById(identifier)
    return self.recv_getRecordById()

  def send_getRecordById(self, identifier):
    self._oprot.writeMessageBegin('getRecordById', TMessageType.CALL, self._seqid)
    args = getRecordById_args()
    args.identifier = identifier
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecordById(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecordById_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecordById failed: unknown result");

  def storeRecord(self, record):
    """
    Store the given Record.  Usually disabled.

    Parameters:
     - record
    """
    self.send_storeRecord(record)
    self.recv_storeRecord()

  def send_storeRecord(self, record):
    self._oprot.writeMessageBegin('storeRecord', TMessageType.CALL, self._seqid)
    args = storeRecord_args()
    args.record = record
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeRecord(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = storeRecord_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ssex is not None:
      raise result.ssex
    return

  def getMultiRecord(self, texts):
    """
    Returns a MultiRecord for a given list of texts.

    Parameters:
     - texts
    """
    self.send_getMultiRecord(texts)
    return self.recv_getMultiRecord()

  def send_getMultiRecord(self, texts):
    self._oprot.writeMessageBegin('getMultiRecord', TMessageType.CALL, self._seqid)
    args = getMultiRecord_args()
    args.texts = texts
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getMultiRecord(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getMultiRecord_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMultiRecord failed: unknown result");

  def provideMulti(self, view_name, texts, forceUpdate):
    """
    Provides the view_name for multiple texts in a MultiRecord.

    Parameters:
     - view_name
     - texts
     - forceUpdate
    """
    self.send_provideMulti(view_name, texts, forceUpdate)
    return self.recv_provideMulti()

  def send_provideMulti(self, view_name, texts, forceUpdate):
    self._oprot.writeMessageBegin('provideMulti', TMessageType.CALL, self._seqid)
    args = provideMulti_args()
    args.view_name = view_name
    args.texts = texts
    args.forceUpdate = forceUpdate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_provideMulti(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = provideMulti_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.suex is not None:
      raise result.suex
    if result.afex is not None:
      raise result.afex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "provideMulti failed: unknown result");

  def storeMultiRecord(self, record):
    """
    Store the given MultiRecord.  Usually disabled.

    Parameters:
     - record
    """
    self.send_storeMultiRecord(record)
    self.recv_storeMultiRecord()

  def send_storeMultiRecord(self, record):
    self._oprot.writeMessageBegin('storeMultiRecord', TMessageType.CALL, self._seqid)
    args = storeMultiRecord_args()
    args.record = record
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_storeMultiRecord(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = storeMultiRecord_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ssex is not None:
      raise result.ssex
    return


class Processor(cogcomp.base.BaseService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    cogcomp.base.BaseService.Processor.__init__(self, handler)
    self._processMap["describeAnnotations"] = Processor.process_describeAnnotations
    self._processMap["isCacheAvailable"] = Processor.process_isCacheAvailable
    self._processMap["provide"] = Processor.process_provide
    self._processMap["wsprovide"] = Processor.process_wsprovide
    self._processMap["getRecord"] = Processor.process_getRecord
    self._processMap["wsgetRecord"] = Processor.process_wsgetRecord
    self._processMap["getRecordById"] = Processor.process_getRecordById
    self._processMap["storeRecord"] = Processor.process_storeRecord
    self._processMap["getMultiRecord"] = Processor.process_getMultiRecord
    self._processMap["provideMulti"] = Processor.process_provideMulti
    self._processMap["storeMultiRecord"] = Processor.process_storeMultiRecord

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_describeAnnotations(self, seqid, iprot, oprot):
    args = describeAnnotations_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeAnnotations_result()
    result.success = self._handler.describeAnnotations()
    oprot.writeMessageBegin("describeAnnotations", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_isCacheAvailable(self, seqid, iprot, oprot):
    args = isCacheAvailable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = isCacheAvailable_result()
    result.success = self._handler.isCacheAvailable()
    oprot.writeMessageBegin("isCacheAvailable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_provide(self, seqid, iprot, oprot):
    args = provide_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = provide_result()
    try:
      result.success = self._handler.provide(args.view_name, args.text, args.forceUpdate)
    except cogcomp.base.ttypes.ServiceUnavailableException, suex:
      result.suex = suex
    except cogcomp.base.ttypes.AnnotationFailedException, afex:
      result.afex = afex
    oprot.writeMessageBegin("provide", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_wsprovide(self, seqid, iprot, oprot):
    args = wsprovide_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = wsprovide_result()
    try:
      result.success = self._handler.wsprovide(args.view_name, args.sentences, args.forceUpdate)
    except cogcomp.base.ttypes.ServiceUnavailableException, suex:
      result.suex = suex
    except cogcomp.base.ttypes.AnnotationFailedException, afex:
      result.afex = afex
    oprot.writeMessageBegin("wsprovide", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecord(self, seqid, iprot, oprot):
    args = getRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecord_result()
    try:
      result.success = self._handler.getRecord(args.text)
    except cogcomp.base.ttypes.ServiceUnavailableException, ex:
      result.ex = ex
    except cogcomp.base.ttypes.AnnotationFailedException, ex2:
      result.ex2 = ex2
    oprot.writeMessageBegin("getRecord", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_wsgetRecord(self, seqid, iprot, oprot):
    args = wsgetRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = wsgetRecord_result()
    try:
      result.success = self._handler.wsgetRecord(args.sentences)
    except cogcomp.base.ttypes.ServiceUnavailableException, ex:
      result.ex = ex
    except cogcomp.base.ttypes.AnnotationFailedException, ex2:
      result.ex2 = ex2
    oprot.writeMessageBegin("wsgetRecord", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecordById(self, seqid, iprot, oprot):
    args = getRecordById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecordById_result()
    try:
      result.success = self._handler.getRecordById(args.identifier)
    except cogcomp.base.ttypes.ServiceUnavailableException, ex:
      result.ex = ex
    except cogcomp.base.ttypes.AnnotationFailedException, ex2:
      result.ex2 = ex2
    oprot.writeMessageBegin("getRecordById", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeRecord(self, seqid, iprot, oprot):
    args = storeRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeRecord_result()
    try:
      self._handler.storeRecord(args.record)
    except cogcomp.base.ttypes.ServiceSecurityException, ssex:
      result.ssex = ssex
    oprot.writeMessageBegin("storeRecord", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getMultiRecord(self, seqid, iprot, oprot):
    args = getMultiRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getMultiRecord_result()
    try:
      result.success = self._handler.getMultiRecord(args.texts)
    except cogcomp.base.ttypes.ServiceUnavailableException, ex:
      result.ex = ex
    except cogcomp.base.ttypes.AnnotationFailedException, ex2:
      result.ex2 = ex2
    oprot.writeMessageBegin("getMultiRecord", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_provideMulti(self, seqid, iprot, oprot):
    args = provideMulti_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = provideMulti_result()
    try:
      result.success = self._handler.provideMulti(args.view_name, args.texts, args.forceUpdate)
    except cogcomp.base.ttypes.ServiceUnavailableException, suex:
      result.suex = suex
    except cogcomp.base.ttypes.AnnotationFailedException, afex:
      result.afex = afex
    oprot.writeMessageBegin("provideMulti", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_storeMultiRecord(self, seqid, iprot, oprot):
    args = storeMultiRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = storeMultiRecord_result()
    try:
      self._handler.storeMultiRecord(args.record)
    except cogcomp.base.ttypes.ServiceSecurityException, ssex:
      result.ssex = ssex
    oprot.writeMessageBegin("storeMultiRecord", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class describeAnnotations_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeAnnotations_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeAnnotations_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype80, _vtype81, _size79 ) = iprot.readMapBegin()
          for _i83 in xrange(_size79):
            _key84 = iprot.readString();
            _val85 = iprot.readString();
            self.success[_key84] = _val85
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeAnnotations_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter86,viter87 in self.success.items():
        oprot.writeString(kiter86)
        oprot.writeString(viter87)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isCacheAvailable_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isCacheAvailable_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class isCacheAvailable_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('isCacheAvailable_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class provide_args:
  """
  Attributes:
   - view_name
   - text
   - forceUpdate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'view_name', None, None, ), # 1
    (2, TType.STRING, 'text', None, None, ), # 2
    (3, TType.BOOL, 'forceUpdate', None, None, ), # 3
  )

  def __init__(self, view_name=None, text=None, forceUpdate=None,):
    self.view_name = view_name
    self.text = text
    self.forceUpdate = forceUpdate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.view_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.forceUpdate = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('provide_args')
    if self.view_name is not None:
      oprot.writeFieldBegin('view_name', TType.STRING, 1)
      oprot.writeString(self.view_name)
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 2)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.forceUpdate is not None:
      oprot.writeFieldBegin('forceUpdate', TType.BOOL, 3)
      oprot.writeBool(self.forceUpdate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class provide_result:
  """
  Attributes:
   - success
   - suex
   - afex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Record, Record.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'suex', (cogcomp.base.ttypes.ServiceUnavailableException, cogcomp.base.ttypes.ServiceUnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'afex', (cogcomp.base.ttypes.AnnotationFailedException, cogcomp.base.ttypes.AnnotationFailedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, suex=None, afex=None,):
    self.success = success
    self.suex = suex
    self.afex = afex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Record()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.suex = cogcomp.base.ttypes.ServiceUnavailableException()
          self.suex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.afex = cogcomp.base.ttypes.AnnotationFailedException()
          self.afex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('provide_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.suex is not None:
      oprot.writeFieldBegin('suex', TType.STRUCT, 1)
      self.suex.write(oprot)
      oprot.writeFieldEnd()
    if self.afex is not None:
      oprot.writeFieldBegin('afex', TType.STRUCT, 2)
      self.afex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class wsprovide_args:
  """
  Attributes:
   - view_name
   - sentences
   - forceUpdate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'view_name', None, None, ), # 1
    (2, TType.LIST, 'sentences', (TType.STRING,None), None, ), # 2
    (3, TType.BOOL, 'forceUpdate', None, None, ), # 3
  )

  def __init__(self, view_name=None, sentences=None, forceUpdate=None,):
    self.view_name = view_name
    self.sentences = sentences
    self.forceUpdate = forceUpdate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.view_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sentences = []
          (_etype91, _size88) = iprot.readListBegin()
          for _i92 in xrange(_size88):
            _elem93 = iprot.readString();
            self.sentences.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.forceUpdate = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('wsprovide_args')
    if self.view_name is not None:
      oprot.writeFieldBegin('view_name', TType.STRING, 1)
      oprot.writeString(self.view_name)
      oprot.writeFieldEnd()
    if self.sentences is not None:
      oprot.writeFieldBegin('sentences', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.sentences))
      for iter94 in self.sentences:
        oprot.writeString(iter94)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.forceUpdate is not None:
      oprot.writeFieldBegin('forceUpdate', TType.BOOL, 3)
      oprot.writeBool(self.forceUpdate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class wsprovide_result:
  """
  Attributes:
   - success
   - suex
   - afex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Record, Record.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'suex', (cogcomp.base.ttypes.ServiceUnavailableException, cogcomp.base.ttypes.ServiceUnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'afex', (cogcomp.base.ttypes.AnnotationFailedException, cogcomp.base.ttypes.AnnotationFailedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, suex=None, afex=None,):
    self.success = success
    self.suex = suex
    self.afex = afex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Record()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.suex = cogcomp.base.ttypes.ServiceUnavailableException()
          self.suex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.afex = cogcomp.base.ttypes.AnnotationFailedException()
          self.afex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('wsprovide_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.suex is not None:
      oprot.writeFieldBegin('suex', TType.STRUCT, 1)
      self.suex.write(oprot)
      oprot.writeFieldEnd()
    if self.afex is not None:
      oprot.writeFieldBegin('afex', TType.STRUCT, 2)
      self.afex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecord_args:
  """
  Attributes:
   - text
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
  )

  def __init__(self, text=None,):
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecord_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Record, Record.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (cogcomp.base.ttypes.ServiceUnavailableException, cogcomp.base.ttypes.ServiceUnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (cogcomp.base.ttypes.AnnotationFailedException, cogcomp.base.ttypes.AnnotationFailedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Record()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = cogcomp.base.ttypes.ServiceUnavailableException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = cogcomp.base.ttypes.AnnotationFailedException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class wsgetRecord_args:
  """
  Attributes:
   - sentences
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'sentences', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, sentences=None,):
    self.sentences = sentences

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.sentences = []
          (_etype98, _size95) = iprot.readListBegin()
          for _i99 in xrange(_size95):
            _elem100 = iprot.readString();
            self.sentences.append(_elem100)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('wsgetRecord_args')
    if self.sentences is not None:
      oprot.writeFieldBegin('sentences', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.sentences))
      for iter101 in self.sentences:
        oprot.writeString(iter101)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class wsgetRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Record, Record.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (cogcomp.base.ttypes.ServiceUnavailableException, cogcomp.base.ttypes.ServiceUnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (cogcomp.base.ttypes.AnnotationFailedException, cogcomp.base.ttypes.AnnotationFailedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Record()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = cogcomp.base.ttypes.ServiceUnavailableException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = cogcomp.base.ttypes.AnnotationFailedException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('wsgetRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecordById_args:
  """
  Attributes:
   - identifier
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'identifier', None, None, ), # 1
  )

  def __init__(self, identifier=None,):
    self.identifier = identifier

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.identifier = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecordById_args')
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.STRING, 1)
      oprot.writeString(self.identifier)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecordById_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Record, Record.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (cogcomp.base.ttypes.ServiceUnavailableException, cogcomp.base.ttypes.ServiceUnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (cogcomp.base.ttypes.AnnotationFailedException, cogcomp.base.ttypes.AnnotationFailedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Record()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = cogcomp.base.ttypes.ServiceUnavailableException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = cogcomp.base.ttypes.AnnotationFailedException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecordById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeRecord_args:
  """
  Attributes:
   - record
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'record', (Record, Record.thrift_spec), None, ), # 1
  )

  def __init__(self, record=None,):
    self.record = record

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.record = Record()
          self.record.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.STRUCT, 1)
      self.record.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeRecord_result:
  """
  Attributes:
   - ssex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ssex', (cogcomp.base.ttypes.ServiceSecurityException, cogcomp.base.ttypes.ServiceSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, ssex=None,):
    self.ssex = ssex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ssex = cogcomp.base.ttypes.ServiceSecurityException()
          self.ssex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeRecord_result')
    if self.ssex is not None:
      oprot.writeFieldBegin('ssex', TType.STRUCT, 1)
      self.ssex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMultiRecord_args:
  """
  Attributes:
   - texts
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'texts', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, texts=None,):
    self.texts = texts

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.texts = []
          (_etype105, _size102) = iprot.readListBegin()
          for _i106 in xrange(_size102):
            _elem107 = iprot.readString();
            self.texts.append(_elem107)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMultiRecord_args')
    if self.texts is not None:
      oprot.writeFieldBegin('texts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.texts))
      for iter108 in self.texts:
        oprot.writeString(iter108)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getMultiRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MultiRecord, MultiRecord.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (cogcomp.base.ttypes.ServiceUnavailableException, cogcomp.base.ttypes.ServiceUnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (cogcomp.base.ttypes.AnnotationFailedException, cogcomp.base.ttypes.AnnotationFailedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MultiRecord()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = cogcomp.base.ttypes.ServiceUnavailableException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = cogcomp.base.ttypes.AnnotationFailedException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getMultiRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class provideMulti_args:
  """
  Attributes:
   - view_name
   - texts
   - forceUpdate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'view_name', None, None, ), # 1
    (2, TType.LIST, 'texts', (TType.STRING,None), None, ), # 2
    (3, TType.BOOL, 'forceUpdate', None, None, ), # 3
  )

  def __init__(self, view_name=None, texts=None, forceUpdate=None,):
    self.view_name = view_name
    self.texts = texts
    self.forceUpdate = forceUpdate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.view_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.texts = []
          (_etype112, _size109) = iprot.readListBegin()
          for _i113 in xrange(_size109):
            _elem114 = iprot.readString();
            self.texts.append(_elem114)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.forceUpdate = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('provideMulti_args')
    if self.view_name is not None:
      oprot.writeFieldBegin('view_name', TType.STRING, 1)
      oprot.writeString(self.view_name)
      oprot.writeFieldEnd()
    if self.texts is not None:
      oprot.writeFieldBegin('texts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.texts))
      for iter115 in self.texts:
        oprot.writeString(iter115)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.forceUpdate is not None:
      oprot.writeFieldBegin('forceUpdate', TType.BOOL, 3)
      oprot.writeBool(self.forceUpdate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class provideMulti_result:
  """
  Attributes:
   - success
   - suex
   - afex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MultiRecord, MultiRecord.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'suex', (cogcomp.base.ttypes.ServiceUnavailableException, cogcomp.base.ttypes.ServiceUnavailableException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'afex', (cogcomp.base.ttypes.AnnotationFailedException, cogcomp.base.ttypes.AnnotationFailedException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, suex=None, afex=None,):
    self.success = success
    self.suex = suex
    self.afex = afex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MultiRecord()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.suex = cogcomp.base.ttypes.ServiceUnavailableException()
          self.suex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.afex = cogcomp.base.ttypes.AnnotationFailedException()
          self.afex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('provideMulti_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.suex is not None:
      oprot.writeFieldBegin('suex', TType.STRUCT, 1)
      self.suex.write(oprot)
      oprot.writeFieldEnd()
    if self.afex is not None:
      oprot.writeFieldBegin('afex', TType.STRUCT, 2)
      self.afex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeMultiRecord_args:
  """
  Attributes:
   - record
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'record', (MultiRecord, MultiRecord.thrift_spec), None, ), # 1
  )

  def __init__(self, record=None,):
    self.record = record

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.record = MultiRecord()
          self.record.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeMultiRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.STRUCT, 1)
      self.record.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class storeMultiRecord_result:
  """
  Attributes:
   - ssex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ssex', (cogcomp.base.ttypes.ServiceSecurityException, cogcomp.base.ttypes.ServiceSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, ssex=None,):
    self.ssex = ssex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ssex = cogcomp.base.ttypes.ServiceSecurityException()
          self.ssex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('storeMultiRecord_result')
    if self.ssex is not None:
      oprot.writeFieldBegin('ssex', TType.STRUCT, 1)
      self.ssex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
